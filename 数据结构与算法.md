# 数据结构与算法

## 数组

| 数组类型    | 存储地址                             |
| ------- | -------------------------------- |
| a[n]    | a[i]的存储地址：a+i*len                |
| a[m][n] | a[i][j]的存储地址（按行存储）：a+(i*n+j)*len |
|         | a[i][j]的存储地址（按列存储）：a+(j*m+i)*len |

## 稀疏矩阵

| 稀疏矩阵 |     |
| ---- | --- |
| 上三角  |     |
| 下三角  |     |

## 数据结构的定义

+ 线性结构

+ 非线性结构
  
  + 树
  
  + 图-图里有环路

## 线性表

+ 顺序表

+ 链表
  
  + 单链表
    
    + 单链表删除节点
    
    + 单链表插入节点
  
  + 循环链表
  
  + 双向链表

|      |      | 顺序存储       | 链式存储       |
| ---- | ---- | ---------- | ---------- |
| 空间性能 | 存储密度 | =1，更优      | <1         |
|      | 容量分配 | 事先确定       | 动态改变，更优    |
| 时间性能 | 查找   | O(n/2)     | O(n/2)     |
|      | 读    | O(1)，更优    | O((n+1)/2) |
|      | 插入   | O(n/2)     | O(1)，更优    |
|      | 删除   | O((n-1)/2) | O(1)，更优    |

### 队列与栈

+ 队列-先进先出
  
  + 循环队列

+ 栈-先进后出

### 广义表

广义表是n个表元素组成的有限序列

+ 长度-最外层包含的元素个数

+ 深度-嵌套的层数

S1=(a, (b, c), (d, e))
取表头 head(S1) = a
取表尾 tail(S1) = ((b, c), (d, e))

## 树

+ 满二叉树

+ 完全二叉树
  
  + 除了最底下一层，其余层都是满的。并且底层是从左到右排列

+ 查找二叉树-二叉排序树
  
  + 左孩子小于根
  
  + 右孩子大于根
  
  + 不可能存在两个节点值相等

+ 最优二叉树 哈夫曼数
  
  + 带权路径长度最短
  
  + 只需要叶子节点的权之和

+ 线索二叉树

+ 平衡二叉树
  
  + 每个节点的平衡度只能是1 0 -1

对任意一颗二叉树，如果其叶子节点数是n0,度为2的节点数是n2,则n0=n2+1

### 二叉树遍历

+ 层次遍历

+ 前序遍历

+ 中序遍历

+ 后序遍历

### 反向构造二叉树

### 树转二叉树

+ 孩子节点-左子树节点

+ 兄弟节点-右孩子节点

### 查找二叉树

+ 插入节点
  
  + 若该值存在，则不插入
  
  + 若数为空数，则以新节点为查找二叉树
  
  + 否则从根节点开始，依次比较

+ 删除节点
  
  + 若待删除节点是叶子节点，则直接删除
  
  + 若待删除节点只有一个子节点，则其子节点与父节点直接连接
  
  + 若待删除节点有两个子节点，则在其左子树找到最大值s，替换被删除节点。s的删除一定符合上面2条原则

### 最优二叉树

无损压缩

### 线索二叉树

叶子节点

+ 左指针指向序列中前一个节点

+ 右指针指向序列中后一个节点

### 平衡二叉树

## 图

完全图

+ 无向图中，每两个顶点之间都有一条边相连，则为完全图

+ 有向图中，每两个顶点之间有两条有向边相连，则为完全图

图的存储

+ 邻接矩阵Rij
  
  + 1 顶点i到顶点j有邻接边
  
  + 0 顶点i到顶点j无邻接边

+ 邻接表

### 图的遍历

+ 深度优先

+ 广度优先

### 拓扑排序

### 图的最小生成树

+ 普里姆算法

+ 克鲁斯卡尔算法

## 算法

+ 有穷性
  
  + 执行有穷步之后结束

+ 确定性
  
  + 算法的每一条指令必须有确切的含义，不能含糊不清

+ 输入 至少0个

+ 输出 至少1个

+ 有效性
  
  + 算法的每个步骤都能有效执行并得到确定的结果

### 复杂度

+ 时间复杂度

+ 空间复杂度

## 查找

+ 顺序查找 O(n)

+ 二分查找 O(log2(n))
  
  + 前提是有序排列

+ 散列表
  
  + 处理冲突机制
    
    + 线性探测法
    
    + 伪随机数法

## 排序

性质分类

+ 稳定排序
  
  + 等值的键，排序后顺序不变

+ 不稳定排序

方法分类

+ 插入类
  
  + 直接插入
    
    + 当插入第i个记录时，R1，R2，...R(i-1)已排好序。第i个记录将依次比较
  
  + 希尔排序
    
    + 分组类型的直接插入排序

+ 交换排序
  
  + 冒泡排序
    
    + 相邻元素之间的比较和交换，将排序码较小的元素逐渐从底部移动顶部
  
  + 快速排序
    
    + 分治法

+ 选择类
  
  + 简单选择排序
    
    + 在所有记录中选出最小的记录，把它与第一个交换，然后在其余的记录中选出最小的，与第2个交换...
  
  + 堆排序-前10个求出来

+ 并归排序

+ 基数排序
  
  + 按个位 十位 百位 来排序

|      |       | 平均情况 | 最坏情况 | 空间复杂度 | 稳定性 |
| ---- | ----- | ---- | ---- | ----- | --- |
| 插入排序 | 直接插入  |      |      | O(1)  | 稳定  |
|      | Shell |      |      | O(1)  |     |
| 选择排序 | 直接选择  |      |      | O(1)  |     |
|      | 堆排序   |      |      | O(1)  |     |
| 交换排序 | 冒泡    |      |      | O(1)  | 稳定  |
|      | 快速    |      |      |       |     |
| 归并排序 |       |      |      | O(n)  | 稳定  |
| 基数排序 |       |      |      |       | 稳定  |
